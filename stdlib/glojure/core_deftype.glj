;; A heavily modified version of core_deftype.clj

;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(in-ns 'glojure.core)

(def
  ^{:private true
    :doc "Private store of protocols. Go's reflection capabilities
    don't yet support a native interface-based implementation, so
    protocols are implemented in Glojure as maps from type to protocol
    method implementations."}
  -protocols (atom {}))

(defmacro defprotocol
  "A protocol is a named set of named methods and their signatures:
  (defprotocol AProtocolName

    ;optional doc string
    \"A doc string for AProtocol abstraction\"

   ;options
   :extend-via-metadata true

  ;method signatures
    (bar [this a b] \"bar docs\")
    (baz [this a] [this a b] [this a b c] \"baz docs\"))

  No implementations are provided. Docs can be specified for the
  protocol overall and for each method. The above yields a set of
  polymorphic functions and a protocol object. All are
  namespace-qualified by the ns enclosing the definition The resulting
  functions dispatch on the type of their first argument, which is
  required and corresponds to the implicit target object ('this' in 
  Java parlance). defprotocol is dynamic, has no special compile-time 
  effect, and defines no new types or classes. Implementations of 
  the protocol methods can be provided using extend.

  When :extend-via-metadata is true, values can extend protocols by
  adding metadata where keys are fully-qualified protocol function
  symbols and values are function implementations. Protocol
  implementations are checked first for direct definitions (defrecord,
  deftype, reify), then metadata definitions, then external
  extensions (extend, extend-type, extend-protocol)

  defprotocol will automatically generate a corresponding interface,
  with the same name as the protocol, i.e. given a protocol:
  my.ns/Protocol, an interface: my.ns.Protocol. The interface will
  have methods corresponding to the protocol functions, and the
  protocol will automatically work with instances of the interface.

  Note that you should not use this interface with deftype or
  reify, as they support the protocol directly:

  (defprotocol P 
    (foo [this]) 
    (bar-me [this] [this y]))

  (deftype Foo [a b c] 
   P
    (foo [this] a)
    (bar-me [this] b)
    (bar-me [this y] (+ c y)))
  
  (bar-me (Foo. 1 2 3) 42)
  => 45

  (foo 
    (let [x 42]
      (reify P 
        (foo [this] 17)
        (bar-me [this] x)
        (bar-me [this y] x))))
  => 17"
  [name & opts+sigs]
  ;; todo: verify args
  (let [doc (when (string? (first opts+sigs)) (first opts+sigs))
        opts+sigs (if doc (rest opts+sigs) opts+sigs)
        sigs opts+sigs]
    `(do (swap! -protocols assoc '~name {
                                         :sigs '~sigs
                                         :impls {}
                                         })
         ~@(map
            (fn [sig]
              `(defn ~(first sig)
                 [~'this & ~'args]
                 (let [~'method-name ~(keyword (first sig))
                       ~'method (get-in @-protocols ['~name :impls (class ~'this) ~'method-name])]
                   (if ~'method
                     (apply ~'method ~'args)
                     (throw (fmt.Errorf "No implementation of method: %v of protocol: %v found for type: %T"
                                        ~'method-name "foo" ~'this))))))
            sigs))))

